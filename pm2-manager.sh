#!/bin/bash

# Obelisk Core PM2 Manager
# Manages obelisk-core API server + inference service with PM2
# Auto-generates ecosystem config, manages logs, and handles restarts
#
# Usage:
#   ./pm2-manager.sh <command> [service]
#
# Commands apply to ALL services by default.
# Pass a service name to target just one:
#   ./pm2-manager.sh restart              # restart all
#   ./pm2-manager.sh restart inference    # restart inference only
#   ./pm2-manager.sh stop core            # stop obelisk-core only

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_DIR="$SCRIPT_DIR/logs"
ECOSYSTEM_FILE="$SCRIPT_DIR/ecosystem.config.js"

# ‚îÄ‚îÄ‚îÄ Service definitions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Apps load their own .env from cwd (no env wiring in PM2; same as cabal-eco).
# Each service: PM2_NAME  PORT  HOST  MODULE
#
# Core always runs the TypeScript build (ts/dist/index.js).
# Inference runs the Python service (src/inference/).
CORE_DEBUG="${OBELISK_CORE_DEBUG:-false}"

CORE_NAME="obelisk-core"
CORE_PORT="${OBELISK_CORE_PORT:-7779}"
CORE_HOST="${OBELISK_CORE_HOST:-0.0.0.0}"

INFERENCE_NAME="obelisk-inference"
INFERENCE_PORT="${INFERENCE_PORT:-7780}"
INFERENCE_HOST="${INFERENCE_HOST:-127.0.0.1}"

BLOCKCHAIN_NAME="obelisk-blockchain"

ALL_SERVICES=("$CORE_NAME" "$INFERENCE_NAME" "$BLOCKCHAIN_NAME")

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Ensure log directory exists
mkdir -p "$LOG_DIR"

# ‚îÄ‚îÄ‚îÄ PM2 check ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if ! command -v pm2 &> /dev/null; then
    if ! command -v npm &> /dev/null; then
        echo -e "${RED}‚ùå PM2 is not installed and npm was not found.${NC}"
        echo -e "${YELLOW}   Please install Node.js and npm first: https://nodejs.org/${NC}"
        exit 1
    fi
    echo -e "${RED}‚ùå PM2 is not installed. Installing...${NC}"
    if ! npm install -g pm2 2>/dev/null; then
        echo -e "${RED}‚ùå Failed to install PM2 globally (likely a permissions issue).${NC}"
        echo -e "${YELLOW}   Try: sudo npm install -g pm2${NC}"
        exit 1
    fi
fi

# ‚îÄ‚îÄ‚îÄ Resolve service name from user input ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Maps shortcuts like "inference", "core", "all" to PM2 service names.
# Returns empty string for "all" (meaning target everything).
resolve_service() {
    local input="$1"
    case "$input" in
        ""|all)
            echo ""  # empty = all services
            ;;
        core|obelisk-core)
            echo "$CORE_NAME"
            ;;
        inference|obelisk-inference|infer)
            echo "$INFERENCE_NAME"
            ;;
        blockchain|obelisk-blockchain|blockchain-service)
            echo "$BLOCKCHAIN_NAME"
            ;;
        *)
            echo -e "${RED}‚ùå Unknown service: $input${NC}" >&2
            echo -e "${YELLOW}   Valid services: core, inference, blockchain, all${NC}" >&2
            exit 1
            ;;
    esac
}

# ‚îÄ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

setup_logrotate() {
    if ! pm2 describe pm2-logrotate &> /dev/null; then
        echo -e "${YELLOW}‚ö†Ô∏è  PM2 logrotate not found. Installing...${NC}"
        pm2 install pm2-logrotate
    fi
    # Rotate when log reaches 5MB; no compression; only size-based, not time-based wipe
    pm2 set pm2-logrotate:max_size 5M
    pm2 set pm2-logrotate:retain 5
    pm2 set pm2-logrotate:compress false
    pm2 set pm2-logrotate:dateFormat YYYY-MM-DD_HH-mm-ss
    pm2 set pm2-logrotate:workerInterval 30
    pm2 set pm2-logrotate:rotateModule true
    echo -e "${GREEN}‚úÖ PM2 logrotate configured (rotate at 5MB, no compression)${NC}"
}

generate_ecosystem() {
    cat > "$ECOSYSTEM_FILE" << ECOSYSTEMEOF
// Auto-generated by pm2-manager.sh ‚Äî do not edit manually
const path = require('path');

module.exports = {
  apps: [
    {
      name: '${CORE_NAME}',
      script: path.resolve(__dirname, 'ts/dist/index.js'),
      args: '',
      interpreter: 'node',
      cwd: path.resolve(__dirname),
      instances: 1,
      exec_mode: 'fork',
      env: {},
      log_file: path.resolve(__dirname, 'logs', 'obelisk-core.log'),
      out_file: '/dev/null',
      error_file: '/dev/null',
      time: true,
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      merge_logs: true,
      autorestart: true,
      watch: false,
      max_memory_restart: '512M',
      min_uptime: '10s',
      max_restarts: 10,
    },
    {
      name: '${INFERENCE_NAME}',
      script: path.resolve(__dirname, 'venv/bin/python'),
      args: '-m uvicorn src.inference.server:app --host ${INFERENCE_HOST} --port ${INFERENCE_PORT} --no-access-log',
      interpreter: 'none',
      cwd: path.resolve(__dirname),
      instances: 1,
      exec_mode: 'fork',
      env: { PYTHONUNBUFFERED: '1' },
      log_file: path.resolve(__dirname, 'logs', 'obelisk-inference.log'),
      out_file: '/dev/null',
      error_file: '/dev/null',
      time: true,
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      merge_logs: true,
      autorestart: true,
      watch: false,
      max_memory_restart: '4G',
      min_uptime: '10s',
      max_restarts: 10,
    },
    {
      name: '${BLOCKCHAIN_NAME}',
      script: path.resolve(__dirname, 'blockchain-service/dist/index.js'),
      args: '',
      interpreter: 'node',
      cwd: path.resolve(__dirname, 'blockchain-service'),
      instances: 1,
      exec_mode: 'fork',
      env: {},
      log_file: path.resolve(__dirname, 'logs', 'obelisk-blockchain.log'),
      out_file: '/dev/null',
      error_file: '/dev/null',
      time: true,
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      merge_logs: true,
      autorestart: true,
      watch: false,
      max_memory_restart: '512M',
      min_uptime: '10s',
      max_restarts: 10,
    }
  ]
};
ECOSYSTEMEOF
    echo -e "${GREEN}‚úÖ Ecosystem config generated${NC}"
}

# Check if a specific PM2 service exists
service_exists() {
    pm2 list 2>/dev/null | grep -q "$1"
}

# Check if a specific PM2 service is online
is_running() {
    if service_exists "$1"; then
        pm2 list 2>/dev/null | grep "$1" | grep -q "online"
    else
        return 1
    fi
}

# Get list of services to operate on (all or just one)
get_target_services() {
    local target="$1"
    if [ -z "$target" ]; then
        echo "${ALL_SERVICES[@]}"
    else
        echo "$target"
    fi
}

# Delete log files for a service (or all). Removes current log, rotated (e.g. name__date.log), and .gz.
delete_logs() {
    local target="$1"
    if [ -d "$LOG_DIR" ]; then
        if [ -z "$target" ]; then
            echo -e "${YELLOW}üóëÔ∏è  Deleting all logs...${NC}"
            rm -f "$LOG_DIR"/*.log "$LOG_DIR"/*.log.* "$LOG_DIR"/*__*.log "$LOG_DIR"/*.gz 2>/dev/null || true
        else
            echo -e "${YELLOW}üóëÔ∏è  Deleting logs for ${target}...${NC}"
            rm -f "$LOG_DIR/${target}".log "$LOG_DIR/${target}".log.* "$LOG_DIR/${target}"__*.log "$LOG_DIR/${target}"*.gz 2>/dev/null || true
        fi
        echo -e "${GREEN}‚úÖ Logs deleted${NC}"
    fi
}

check_venv() {
    local _startup_target="${1:-}"

    # Build TypeScript core when the target includes core or is all services
    if [ -z "$_startup_target" ] || [ "$_startup_target" = "$CORE_NAME" ]; then
        echo -e "${BLUE}üî® Building TypeScript core...${NC}"
        (cd "$SCRIPT_DIR/ts" && npm run build) || {
            echo -e "${RED}‚ùå TypeScript build failed.${NC}"
            echo -e "${YELLOW}   Run: cd ts && npm install && npm run build${NC}"
            return 1
        }
        echo -e "${GREEN}‚úÖ TypeScript build complete${NC}"
    else
        echo -e "${YELLOW}‚ÑπÔ∏è  Skipping TypeScript build (target=${_startup_target})${NC}"
    fi

    # Build blockchain service when the target includes blockchain or is all services
    if [ -z "$_startup_target" ] || [ "$_startup_target" = "$BLOCKCHAIN_NAME" ]; then
        if [ -d "$SCRIPT_DIR/blockchain-service" ]; then
            echo -e "${BLUE}üî® Building blockchain service...${NC}"
            (cd "$SCRIPT_DIR/blockchain-service" && npm run build) || {
                echo -e "${RED}‚ùå Blockchain service build failed.${NC}"
                echo -e "${YELLOW}   Run: cd blockchain-service && npm install && npm run build${NC}"
                return 1
            }
            echo -e "${GREEN}‚úÖ Blockchain service build complete${NC}"
        else
            echo -e "${YELLOW}‚ÑπÔ∏è  blockchain-service/ not found, skipping${NC}"
        fi
    else
        echo -e "${YELLOW}‚ÑπÔ∏è  Skipping blockchain build (target=${_startup_target})${NC}"
    fi

    # Python venv is needed only when starting all services or inference
    if [ -z "$_startup_target" ] || [ "$_startup_target" = "$INFERENCE_NAME" ]; then
        if [ ! -d "$SCRIPT_DIR/venv" ]; then
            echo -e "${RED}‚ùå Virtual environment not found at $SCRIPT_DIR/venv${NC}"
            echo -e "${YELLOW}   Run: python3 -m venv venv && source venv/bin/activate && pip install -r requirements.txt${NC}"
            return 1
        fi
        if [ ! -f "$SCRIPT_DIR/venv/bin/python" ]; then
            echo -e "${RED}‚ùå Python interpreter not found in virtual environment.${NC}"
            return 1
        fi
    fi
    return 0
}

# ‚îÄ‚îÄ‚îÄ Commands ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

cmd_start() {
    local target="$1"

    check_venv "$target" || return 1

    # If starting all, generate ecosystem and start everything
    if [ -z "$target" ]; then
        echo -e "${BLUE}üöÄ Starting all services...${NC}"

        # Delete any existing services first
        for svc in "${ALL_SERVICES[@]}"; do
            if service_exists "$svc"; then
                pm2 delete "$svc" 2>/dev/null || true
            fi
        done

        setup_logrotate
        generate_ecosystem

        cd "$SCRIPT_DIR"
        pm2 start ecosystem.config.js --update-env
        pm2 save

        echo -e "${GREEN}‚úÖ All services started${NC}"
        for svc in "${ALL_SERVICES[@]}"; do
            pm2 list | grep "$svc" || true
        done
    else
        # Start a specific service
        if is_running "$target"; then
            echo -e "${YELLOW}‚ö†Ô∏è  ${target} is already running${NC}"
            pm2 list | grep "$target"
            return 1
        fi

        # Remove if stopped
        if service_exists "$target"; then
            pm2 delete "$target" 2>/dev/null || true
        fi

        echo -e "${BLUE}üöÄ Starting ${target}...${NC}"
        setup_logrotate
        generate_ecosystem

        cd "$SCRIPT_DIR"
        pm2 start ecosystem.config.js --only "$target" --update-env
        pm2 save

        echo -e "${GREEN}‚úÖ ${target} started${NC}"
        pm2 list | grep "$target"
    fi
}

cmd_stop() {
    local target="$1"
    local services
    IFS=' ' read -ra services <<< "$(get_target_services "$target")"

    for svc in "${services[@]}"; do
        if ! service_exists "$svc"; then
            echo -e "${YELLOW}‚ö†Ô∏è  ${svc} is not registered${NC}"
            continue
        fi
        if ! is_running "$svc"; then
            echo -e "${YELLOW}‚ö†Ô∏è  ${svc} is already stopped${NC}"
            continue
        fi
        echo -e "${BLUE}üõë Stopping ${svc}...${NC}"
        pm2 stop "$svc"
        echo -e "${GREEN}‚úÖ ${svc} stopped${NC}"
    done
    pm2 save
}

cmd_restart() {
    local target="$1"

    # Re-generate ecosystem in case env changed
    generate_ecosystem

    if [ -z "$target" ]; then
        # Restart all ‚Äî delete logs so restart starts fresh
        echo -e "${BLUE}üîÑ Restarting all services...${NC}"
        delete_logs ""

        for svc in "${ALL_SERVICES[@]}"; do
            if service_exists "$svc"; then
                pm2 delete "$svc" 2>/dev/null || true
            fi
        done

        cmd_start ""
    else
        # Restart specific service ‚Äî delete that service's logs
        echo -e "${BLUE}üîÑ Restarting ${target}...${NC}"
        delete_logs "$target"

        # Rebuild TypeScript core before restarting
        if [ "$target" = "$CORE_NAME" ]; then
            echo -e "${BLUE}üî® Building TypeScript core...${NC}"
            (cd "$SCRIPT_DIR/ts" && npm run build) || {
                echo -e "${RED}‚ùå TypeScript build failed. Aborting restart.${NC}"
                return 1
            }
            echo -e "${GREEN}‚úÖ TypeScript build complete${NC}"
        fi

        # Rebuild blockchain service before restarting
        if [ "$target" = "$BLOCKCHAIN_NAME" ] && [ -d "$SCRIPT_DIR/blockchain-service" ]; then
            echo -e "${BLUE}üî® Building blockchain service...${NC}"
            (cd "$SCRIPT_DIR/blockchain-service" && npm run build) || {
                echo -e "${RED}‚ùå Blockchain service build failed. Aborting restart.${NC}"
                return 1
            }
            echo -e "${GREEN}‚úÖ Blockchain service build complete${NC}"
        fi

        if service_exists "$target"; then
            if ! is_running "$target"; then
                pm2 delete "$target" 2>/dev/null || true
                cd "$SCRIPT_DIR"
                pm2 start ecosystem.config.js --only "$target" --update-env
            else
                pm2 restart "$target" --update-env
            fi
        else
            cd "$SCRIPT_DIR"
            pm2 start ecosystem.config.js --only "$target" --update-env
        fi

        pm2 save
        echo -e "${GREEN}‚úÖ ${target} restarted${NC}"
        pm2 list | grep "$target"
    fi
}

cmd_status() {
    local target="$1"
    local services
    IFS=' ' read -ra services <<< "$(get_target_services "$target")"

    echo -e "${BLUE}üìä Service Status:${NC}"
    echo ""

    for svc in "${services[@]}"; do
        if service_exists "$svc"; then
            pm2 list | grep "$svc"
            if is_running "$svc"; then
                echo -e "   ${GREEN}‚óè ${svc} is running${NC}"
            else
                echo -e "   ${YELLOW}‚óã ${svc} is stopped${NC}"
            fi
        else
            echo -e "   ${RED}‚úó ${svc} is not registered${NC}"
        fi
    done

    echo ""
    echo -e "${BLUE}üìã Recent logs:${NC}"
    for svc in "${services[@]}"; do
        if service_exists "$svc" && is_running "$svc"; then
            echo -e "${CYAN}--- ${svc} ---${NC}"
            pm2 logs "$svc" --lines 5 --nostream 2>/dev/null || true
            echo ""
        fi
    done
}

cmd_logs() {
    local target="$1"

    if [ -z "$target" ]; then
        echo -e "${BLUE}üìã Showing all logs (Ctrl+C to exit):${NC}"
        pm2 logs
    else
        if ! service_exists "$target"; then
            echo -e "${RED}‚ùå ${target} is not registered${NC}"
            return 1
        fi
        echo -e "${BLUE}üìã Showing ${target} logs (Ctrl+C to exit):${NC}"
        pm2 logs "$target"
    fi
}

cmd_log_files() {
    echo -e "${BLUE}üìÅ Log files:${NC}"
    if [ -d "$LOG_DIR" ] && [ "$(ls -A "$LOG_DIR" 2>/dev/null)" ]; then
        ls -lh "$LOG_DIR" 2>/dev/null
    else
        echo -e "${YELLOW}No log files found${NC}"
    fi
}

# Regenerate ecosystem.config.js from .env and script defaults (no start/stop).
# Use after editing .env or when you want a fresh config before running start/restart.
cmd_init() {
    echo -e "${BLUE}üìù Regenerating ecosystem config from .env...${NC}"
    generate_ecosystem
    setup_logrotate
    echo -e "${GREEN}‚úÖ Ecosystem config written to $ECOSYSTEM_FILE${NC}"
    echo -e "${CYAN}   Run: $0 start   to start services${NC}"
}

cmd_help() {
    echo -e "${BLUE}Obelisk Core PM2 Manager${NC}"
    echo ""
    echo "Usage: $0 <command> [service]"
    echo ""
    echo -e "${CYAN}Commands:${NC}"
    echo "  init                Regenerate ecosystem.config.js from .env (no start/stop)"
    echo "  start [service]     Start service(s)"
    echo "  stop [service]      Stop service(s)"
    echo "  restart [service]   Restart service(s) and delete logs"
    echo "  status [service]    Show service status and recent logs"
    echo "  logs [service]      Show live logs (Ctrl+C to exit)"
    echo "  log-files           List log files and sizes"
    echo "  help                Show this help message"
    echo ""
    echo -e "${CYAN}Services:${NC}"
    echo "  core                Obelisk Core API (port ${CORE_PORT})"
    echo "  inference           Inference Service (port ${INFERENCE_PORT})"
    echo "  blockchain          Clanker blockchain service (block scanner, state to JSON)"
    echo "  all                 All services (default when no service specified)"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo "  $0 init               # Regenerate ecosystem.config.js from .env"
    echo "  $0 start              # Start all services"
    echo "  $0 start inference    # Start inference service only"
    echo "  $0 start blockchain   # Start blockchain service only"
    echo "  $0 restart            # Restart all services"
    echo "  $0 restart core       # Restart obelisk-core only"
    echo "  $0 restart blockchain # Restart blockchain service only"
    echo "  $0 stop inference     # Stop inference service"
    echo "  $0 logs blockchain   # Tail blockchain logs"
    echo "  $0 status             # Status of all services"
    echo ""
    echo -e "${CYAN}Environment:${NC}"
    echo "  OBELISK_CORE_PORT    Core API port (default: 7779)"
    echo "  OBELISK_CORE_HOST    Core API host (default: 0.0.0.0)"
    echo "  OBELISK_CORE_DEBUG   Enable debug logging: 'true' for full untruncated output (default: false)"
    echo "  INFERENCE_PORT       Inference service port (default: 7780)"
    echo "  INFERENCE_HOST       Inference service host (default: 127.0.0.1, set 0.0.0.0 for public)"
    echo "  INFERENCE_SERVICE_URL Inference endpoint URL (default: http://localhost:7780)"
    echo "  INFERENCE_API_KEY    API key for inference service auth (passed to both core & inference)"
    echo "  RPC_URL              Base RPC URL for blockchain service (or set in blockchain-service/.env)"
    echo "  STATE_FILE_PATH      Clanker state JSON path (optional; default blockchain-service/data/clanker_state.json)"
    echo ""
}

# ‚îÄ‚îÄ‚îÄ Main ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

COMMAND="${1:-help}"
SERVICE_INPUT="${2:-}"

# Resolve service name (or empty for all)
if [ -n "$SERVICE_INPUT" ]; then
    TARGET=$(resolve_service "$SERVICE_INPUT")
else
    TARGET=""
fi

case "$COMMAND" in
    start)
        cmd_start "$TARGET"
        ;;
    stop)
        cmd_stop "$TARGET"
        ;;
    restart|restart-all)
        cmd_restart "$TARGET"
        ;;
    status)
        cmd_status "$TARGET"
        ;;
    logs)
        cmd_logs "$TARGET"
        ;;
    log-files)
        cmd_log_files
        ;;
    init|generate-config|config)
        cmd_init
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        echo -e "${RED}‚ùå Unknown command: $COMMAND${NC}"
        cmd_help
        exit 1
        ;;
esac
