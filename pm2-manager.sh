#!/bin/bash

# Obelisk Core PM2 Manager
# Manages obelisk-core API server + inference service with PM2
# Auto-generates ecosystem config, manages logs, and handles restarts
#
# Usage:
#   ./pm2-manager.sh <command> [service]
#
# Commands apply to ALL services by default.
# Pass a service name to target just one:
#   ./pm2-manager.sh restart              # restart all
#   ./pm2-manager.sh restart inference    # restart inference only
#   ./pm2-manager.sh stop core            # stop obelisk-core only

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LOG_DIR="$SCRIPT_DIR/logs"
ECOSYSTEM_FILE="$SCRIPT_DIR/ecosystem.config.js"

# â”€â”€â”€ Service definitions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Each service: PM2_NAME  PORT  HOST  MODULE
#
# OBELISK_CORE_RUNTIME: "typescript" (default) or "python"
# When set to "python", the core service runs the Python build under src/.
CORE_RUNTIME="${OBELISK_CORE_RUNTIME:-typescript}"

CORE_NAME="obelisk-core"
CORE_PORT="${OBELISK_CORE_PORT:-7779}"
CORE_HOST="${OBELISK_CORE_HOST:-0.0.0.0}"

INFERENCE_NAME="obelisk-inference"
INFERENCE_PORT="${INFERENCE_PORT:-7780}"
INFERENCE_HOST="${INFERENCE_HOST:-127.0.0.1}"

ALL_SERVICES=("$CORE_NAME" "$INFERENCE_NAME")

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Ensure log directory exists
mkdir -p "$LOG_DIR"

# â”€â”€â”€ PM2 check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if ! command -v pm2 &> /dev/null; then
    if ! command -v npm &> /dev/null; then
        echo -e "${RED}âŒ PM2 is not installed and npm was not found.${NC}"
        echo -e "${YELLOW}   Please install Node.js and npm first: https://nodejs.org/${NC}"
        exit 1
    fi
    echo -e "${RED}âŒ PM2 is not installed. Installing...${NC}"
    if ! npm install -g pm2 2>/dev/null; then
        echo -e "${RED}âŒ Failed to install PM2 globally (likely a permissions issue).${NC}"
        echo -e "${YELLOW}   Try: sudo npm install -g pm2${NC}"
        exit 1
    fi
fi

# â”€â”€â”€ Resolve service name from user input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Maps shortcuts like "inference", "core", "all" to PM2 service names.
# Returns empty string for "all" (meaning target everything).
resolve_service() {
    local input="$1"
    case "$input" in
        ""|all)
            echo ""  # empty = all services
            ;;
        core|obelisk-core)
            echo "$CORE_NAME"
            ;;
        inference|obelisk-inference|infer)
            echo "$INFERENCE_NAME"
            ;;
        *)
            echo -e "${RED}âŒ Unknown service: $input${NC}" >&2
            echo -e "${YELLOW}   Valid services: core, inference, all${NC}" >&2
            exit 1
            ;;
    esac
}

# â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

setup_logrotate() {
    if ! pm2 describe pm2-logrotate &> /dev/null; then
        echo -e "${YELLOW}âš ï¸  PM2 logrotate not found. Installing...${NC}"
        pm2 install pm2-logrotate
    fi
    pm2 set pm2-logrotate:max_size 10M
    pm2 set pm2-logrotate:retain 5
    pm2 set pm2-logrotate:compress false
    pm2 set pm2-logrotate:dateFormat YYYY-MM-DD_HH-mm-ss
    pm2 set pm2-logrotate:workerInterval 30
    pm2 set pm2-logrotate:rotateInterval "0 0 * * *"
    pm2 set pm2-logrotate:rotateModule true
    echo -e "${GREEN}âœ… PM2 logrotate configured${NC}"
}

generate_ecosystem() {
    # Choose core app config based on runtime
    local core_script core_args core_interpreter core_env_extra core_max_mem
    if [ "$CORE_RUNTIME" = "typescript" ]; then
        core_script="path.resolve(__dirname, 'ts/dist/index.js')"
        core_args="''"
        core_interpreter="'node'"
        core_env_extra="
        NODE_ENV: 'production',
        OBELISK_CORE_PORT: '${CORE_PORT}',
        OBELISK_CORE_HOST: '${CORE_HOST}',"
        core_max_mem="'512M'"
    else
        core_script="path.resolve(__dirname, 'venv/bin/python')"
        core_args="'-m uvicorn src.api.server:app --host ${CORE_HOST} --port ${CORE_PORT} --no-access-log'"
        core_interpreter="'none'"
        core_env_extra="
        NODE_ENV: 'production',
        PYTHONUNBUFFERED: '1',
        OBELISK_CORE_PORT: '${CORE_PORT}',
        OBELISK_CORE_HOST: '${CORE_HOST}',"
        core_max_mem="'1G'"
    fi

    cat > "$ECOSYSTEM_FILE" << ECOSYSTEMEOF
// Auto-generated by pm2-manager.sh â€” do not edit manually
const path = require('path');

module.exports = {
  apps: [
    {
      name: '${CORE_NAME}',
      script: ${core_script},
      args: ${core_args},
      interpreter: ${core_interpreter},
      cwd: path.resolve(__dirname),
      instances: 1,
      exec_mode: 'fork',
      env: {${core_env_extra}
      },
      log_file: path.resolve(__dirname, 'logs', 'obelisk-core.log'),
      out_file: '/dev/null',
      error_file: '/dev/null',
      time: true,
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      merge_logs: true,
      autorestart: true,
      watch: false,
      max_memory_restart: ${core_max_mem},
      min_uptime: '10s',
      max_restarts: 10,
    },
    {
      name: '${INFERENCE_NAME}',
      script: path.resolve(__dirname, 'venv/bin/python'),
      args: '-m uvicorn src.inference.server:app --host ${INFERENCE_HOST} --port ${INFERENCE_PORT} --no-access-log',
      interpreter: 'none',
      cwd: path.resolve(__dirname),
      instances: 1,
      exec_mode: 'fork',
      env: {
        NODE_ENV: 'production',
        PYTHONUNBUFFERED: '1',
        INFERENCE_PORT: '${INFERENCE_PORT}',
        INFERENCE_HOST: '${INFERENCE_HOST}',
      },
      log_file: path.resolve(__dirname, 'logs', 'obelisk-inference.log'),
      out_file: '/dev/null',
      error_file: '/dev/null',
      time: true,
      log_date_format: 'YYYY-MM-DD HH:mm:ss Z',
      merge_logs: true,
      autorestart: true,
      watch: false,
      max_memory_restart: '2G',
      min_uptime: '10s',
      max_restarts: 10,
    }
  ]
};
ECOSYSTEMEOF
    echo -e "${GREEN}âœ… Ecosystem config generated${NC}"
}

# Check if a specific PM2 service exists
service_exists() {
    pm2 list 2>/dev/null | grep -q "$1"
}

# Check if a specific PM2 service is online
is_running() {
    if service_exists "$1"; then
        pm2 list 2>/dev/null | grep "$1" | grep -q "online"
    else
        return 1
    fi
}

# Get list of services to operate on (all or just one)
get_target_services() {
    local target="$1"
    if [ -z "$target" ]; then
        echo "${ALL_SERVICES[@]}"
    else
        echo "$target"
    fi
}

# Delete log files
delete_logs() {
    local target="$1"
    if [ -d "$LOG_DIR" ]; then
        if [ -z "$target" ]; then
            echo -e "${YELLOW}ğŸ—‘ï¸  Deleting all logs...${NC}"
            rm -f "$LOG_DIR"/*.log* 2>/dev/null || true
            rm -f "$LOG_DIR"/*.gz 2>/dev/null || true
        else
            echo -e "${YELLOW}ğŸ—‘ï¸  Deleting logs for ${target}...${NC}"
            rm -f "$LOG_DIR/${target}".log* 2>/dev/null || true
        fi
        echo -e "${GREEN}âœ… Logs deleted${NC}"
    fi
}

check_venv() {
    # TypeScript core: only rebuild when the start target includes the core
    # or when doing a full startup (no target). Skip for inference-only starts.
    local _startup_target="${1:-}"
    if [ "$CORE_RUNTIME" = "typescript" ]; then
        if [ -z "$_startup_target" ] || [ "$_startup_target" = "$CORE_NAME" ]; then
            echo -e "${BLUE}ğŸ”¨ Building TypeScript core...${NC}"
            (cd "$SCRIPT_DIR/ts" && npm run build) || {
                echo -e "${RED}âŒ TypeScript build failed.${NC}"
                echo -e "${YELLOW}   Run: cd ts && npm install && npm run build${NC}"
                return 1
            }
            echo -e "${GREEN}âœ… TypeScript build complete${NC}"
        else
            echo -e "${YELLOW}â„¹ï¸  Skipping TypeScript build (target=${_startup_target})${NC}"
        fi
    fi
    # Python venv is always needed for the inference service
    if [ ! -d "$SCRIPT_DIR/venv" ]; then
        echo -e "${RED}âŒ Virtual environment not found at $SCRIPT_DIR/venv${NC}"
        echo -e "${YELLOW}   Run: python3 -m venv venv && source venv/bin/activate && pip install -r requirements.txt${NC}"
        return 1
    fi
    if [ ! -f "$SCRIPT_DIR/venv/bin/python" ]; then
        echo -e "${RED}âŒ Python interpreter not found in virtual environment.${NC}"
        return 1
    fi
    return 0
}

# â”€â”€â”€ Commands â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

cmd_start() {
    local target="$1"

    check_venv "$target" || return 1

    # If starting all, generate ecosystem and start everything
    if [ -z "$target" ]; then
        echo -e "${BLUE}ğŸš€ Starting all services...${NC}"

        # Delete any existing services first
        for svc in "${ALL_SERVICES[@]}"; do
            if service_exists "$svc"; then
                pm2 delete "$svc" 2>/dev/null || true
            fi
        done

        setup_logrotate
        generate_ecosystem

        cd "$SCRIPT_DIR"
        pm2 start ecosystem.config.js --update-env
        pm2 save

        echo -e "${GREEN}âœ… All services started${NC}"
        for svc in "${ALL_SERVICES[@]}"; do
            pm2 list | grep "$svc" || true
        done
    else
        # Start a specific service
        if is_running "$target"; then
            echo -e "${YELLOW}âš ï¸  ${target} is already running${NC}"
            pm2 list | grep "$target"
            return 1
        fi

        # Remove if stopped
        if service_exists "$target"; then
            pm2 delete "$target" 2>/dev/null || true
        fi

        echo -e "${BLUE}ğŸš€ Starting ${target}...${NC}"
        setup_logrotate
        generate_ecosystem

        cd "$SCRIPT_DIR"
        pm2 start ecosystem.config.js --only "$target" --update-env
        pm2 save

        echo -e "${GREEN}âœ… ${target} started${NC}"
        pm2 list | grep "$target"
    fi
}

cmd_stop() {
    local target="$1"
    local services
    IFS=' ' read -ra services <<< "$(get_target_services "$target")"

    for svc in "${services[@]}"; do
        if ! service_exists "$svc"; then
            echo -e "${YELLOW}âš ï¸  ${svc} is not registered${NC}"
            continue
        fi
        if ! is_running "$svc"; then
            echo -e "${YELLOW}âš ï¸  ${svc} is already stopped${NC}"
            continue
        fi
        echo -e "${BLUE}ğŸ›‘ Stopping ${svc}...${NC}"
        pm2 stop "$svc"
        echo -e "${GREEN}âœ… ${svc} stopped${NC}"
    done
    pm2 save
}

cmd_restart() {
    local target="$1"

    # Re-generate ecosystem in case env changed
    generate_ecosystem

    if [ -z "$target" ]; then
        # Restart all â€” delete logs and start fresh
        echo -e "${BLUE}ğŸ”„ Restarting all services...${NC}"
        delete_logs ""

        for svc in "${ALL_SERVICES[@]}"; do
            if service_exists "$svc"; then
                pm2 delete "$svc" 2>/dev/null || true
            fi
        done

        cmd_start ""
    else
        # Restart specific service
        echo -e "${BLUE}ğŸ”„ Restarting ${target}...${NC}"
        delete_logs "$target"

        # Rebuild TypeScript core before restarting
        if [ "$target" = "$CORE_NAME" ] && [ "$CORE_RUNTIME" = "typescript" ]; then
            echo -e "${BLUE}ğŸ”¨ Building TypeScript core...${NC}"
            (cd "$SCRIPT_DIR/ts" && npm run build) || {
                echo -e "${RED}âŒ TypeScript build failed. Aborting restart.${NC}"
                return 1
            }
            echo -e "${GREEN}âœ… TypeScript build complete${NC}"
        fi

        if service_exists "$target"; then
            if ! is_running "$target"; then
                pm2 delete "$target" 2>/dev/null || true
                cd "$SCRIPT_DIR"
                pm2 start ecosystem.config.js --only "$target" --update-env
            else
                pm2 restart "$target" --update-env
            fi
        else
            cd "$SCRIPT_DIR"
            pm2 start ecosystem.config.js --only "$target" --update-env
        fi

        pm2 save
        echo -e "${GREEN}âœ… ${target} restarted${NC}"
        pm2 list | grep "$target"
    fi
}

cmd_status() {
    local target="$1"
    local services
    IFS=' ' read -ra services <<< "$(get_target_services "$target")"

    echo -e "${BLUE}ğŸ“Š Service Status:${NC}"
    echo ""

    for svc in "${services[@]}"; do
        if service_exists "$svc"; then
            pm2 list | grep "$svc"
            if is_running "$svc"; then
                echo -e "   ${GREEN}â— ${svc} is running${NC}"
            else
                echo -e "   ${YELLOW}â—‹ ${svc} is stopped${NC}"
            fi
        else
            echo -e "   ${RED}âœ— ${svc} is not registered${NC}"
        fi
    done

    echo ""
    echo -e "${BLUE}ğŸ“‹ Recent logs:${NC}"
    for svc in "${services[@]}"; do
        if service_exists "$svc" && is_running "$svc"; then
            echo -e "${CYAN}--- ${svc} ---${NC}"
            pm2 logs "$svc" --lines 5 --nostream 2>/dev/null || true
            echo ""
        fi
    done
}

cmd_logs() {
    local target="$1"

    if [ -z "$target" ]; then
        echo -e "${BLUE}ğŸ“‹ Showing all logs (Ctrl+C to exit):${NC}"
        pm2 logs
    else
        if ! service_exists "$target"; then
            echo -e "${RED}âŒ ${target} is not registered${NC}"
            return 1
        fi
        echo -e "${BLUE}ğŸ“‹ Showing ${target} logs (Ctrl+C to exit):${NC}"
        pm2 logs "$target"
    fi
}

cmd_log_files() {
    echo -e "${BLUE}ğŸ“ Log files:${NC}"
    if [ -d "$LOG_DIR" ] && [ "$(ls -A "$LOG_DIR" 2>/dev/null)" ]; then
        ls -lh "$LOG_DIR" 2>/dev/null
    else
        echo -e "${YELLOW}No log files found${NC}"
    fi
}

cmd_help() {
    echo -e "${BLUE}Obelisk Core PM2 Manager${NC}"
    echo ""
    echo "Usage: $0 <command> [service]"
    echo ""
    echo -e "${CYAN}Commands:${NC}"
    echo "  start [service]     Start service(s)"
    echo "  stop [service]      Stop service(s)"
    echo "  restart [service]   Restart service(s) and delete logs"
    echo "  status [service]    Show service status and recent logs"
    echo "  logs [service]      Show live logs (Ctrl+C to exit)"
    echo "  log-files           List log files and sizes"
    echo "  help                Show this help message"
    echo ""
    echo -e "${CYAN}Services:${NC}"
    echo "  core                Obelisk Core API (port ${CORE_PORT})"
    echo "  inference           Inference Service (port ${INFERENCE_PORT})"
    echo "  all                 All services (default when no service specified)"
    echo ""
    echo -e "${CYAN}Examples:${NC}"
    echo "  $0 start              # Start all services"
    echo "  $0 start inference    # Start inference service only"
    echo "  $0 restart            # Restart all services"
    echo "  $0 restart core       # Restart obelisk-core only"
    echo "  $0 stop inference     # Stop inference service"
    echo "  $0 logs inference     # Tail inference logs"
    echo "  $0 status             # Status of all services"
    echo ""
    echo -e "${CYAN}Environment:${NC}"
    echo "  OBELISK_CORE_PORT    Core API port (default: 7779)"
    echo "  OBELISK_CORE_HOST    Core API host (default: 0.0.0.0)"
    echo "  OBELISK_CORE_RUNTIME Core runtime: 'typescript' (default) or 'python'"
    echo "  INFERENCE_PORT       Inference service port (default: 7780)"
    echo "  INFERENCE_HOST       Inference service host (default: 127.0.0.1, set 0.0.0.0 for public)"
    echo ""
}

# â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

COMMAND="${1:-help}"
SERVICE_INPUT="${2:-}"

# Resolve service name (or empty for all)
if [ -n "$SERVICE_INPUT" ]; then
    TARGET=$(resolve_service "$SERVICE_INPUT")
else
    TARGET=""
fi

case "$COMMAND" in
    start)
        cmd_start "$TARGET"
        ;;
    stop)
        cmd_stop "$TARGET"
        ;;
    restart|restart-all)
        cmd_restart "$TARGET"
        ;;
    status)
        cmd_status "$TARGET"
        ;;
    logs)
        cmd_logs "$TARGET"
        ;;
    log-files)
        cmd_log_files
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        echo -e "${RED}âŒ Unknown command: $COMMAND${NC}"
        cmd_help
        exit 1
        ;;
esac
